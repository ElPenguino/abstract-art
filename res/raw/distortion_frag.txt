//gl_MaxFragmentUniformVectors
//This is the maximum number of 
//vec4 uniform entries that can be used inside a fragment shader. The 
//minimum value supported by all ES 2.0 implementations is 16 vec4
//entries. The number of vec4 uniform entries that can actually be used 
//by a developer can vary from implementation to implementation and 
//from one fragment shader to another. This issue is described in 
//Chapter 8, “Vertex Shaders,” and the same issue applies to fragment 
//shaders.

// see also OpenGL ES 2.0 Programming Guide, pg. 158

precision highp float;
varying highp vec2 v_texCoord;
uniform lowp sampler2D s_texture;
uniform lowp float u_time;
uniform mediump float u_tick;

uniform lowp float u_ampl, u_freq, u_comp;
uniform lowp float u_ampl_delta, u_freq_delta, u_comp_delta;
uniform lowp float u_speed;
uniform lowp float u_dist_duration;

uniform lowp float u_hoffset, u_voffset;
uniform lowp float u_haccel, u_vaccel;
uniform lowp float u_trans_duration;

uniform int u_dist_type;

#define PI 3.141592653589793238462643383279

void main()
{
	vec2 resolution = vec2(256, 256);
	float dx = 0.0;
	float dy = 0.0;

	float C1 = 1.0 / 512.0; // amplitude unit is 1/512ths of a pixel
	float C2 = 8.0 * PI / (1024.0 * 256.0);
	float C3 = PI / 60.0;
	
	float amplitude = (u_ampl + u_ampl_delta * u_tick * 2.0);
	float frequency = (u_freq + u_freq_delta * u_tick * 2.0);
	float compression = (u_comp + u_comp_delta * mod(u_tick, u_dist_duration / 2.0) * 2.0);
	
	float y = v_texCoord.y * resolution.y;
	float x = v_texCoord.x * resolution.x;

	float dist = (C1 * amplitude * sin(C2 * frequency * y + C3 * u_speed * u_tick));

	if(u_dist_type == 0)	// none
	{
		dx = 0.0;
	}
	else if(u_dist_type == 1)	// horizontal
	{
		dx = dist;
		dx /= resolution.y;
	}
	else if(u_dist_type == 2)	// horizontal interlaced
	{
		dx = floor(mod(y, 2.0)) == 0.0 ? dist : -dist;
		dx /= resolution.y;
	}
	else if(u_dist_type == 3)	// vertical
	{
		dy = mod(y * (compression / 256.0) + dist, 256.0);
		if(dy < 0.0) dy = 256.0 + dy;
		if(dy > 255.0) dy = 256.0 - dy;
		
		dy /= resolution.y;
	}
	else
	{
		// well this is awkward
	}
	
	dx += u_hoffset / resolution.x;
	dy += u_voffset / resolution.y;

	gl_FragColor = texture2D(s_texture, vec2(dx + v_texCoord.x, dy + v_texCoord.y) );
}

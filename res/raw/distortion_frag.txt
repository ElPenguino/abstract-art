precision highp float;
varying highp vec2 v_texCoord;
uniform lowp sampler2D s_texture;
uniform lowp float u_time;
uniform mediump float u_tick;

uniform lowp float u_ampl, u_freq, u_comp;
uniform lowp float u_ampl_delta, u_freq_delta, u_comp_delta;
uniform lowp float u_speed;

uniform mediump float u_hoffset, u_voffset;

uniform int u_dist_type;

#define PI 3.141592653589793238462643383279

void main() {

	vec2 resolution = vec2(256, 256);
	float dx = 0.0;
	float dy = 0.0;

	float C1 = 1.0 / 512.0; // amplitude unit is 1/512ths of a pixel
	float C2 = 8.0 * PI / (1024.0 * 256.0);
	float C3 = PI / 60.0;
	
	float amplitude = (u_ampl + u_ampl_delta * u_tick * 2.0);
	float frequency = (u_freq + u_freq_delta * u_tick * 2.0);
	float compression = (u_comp + u_comp_delta * u_tick * 2.0);
	
	float y = v_texCoord.y * resolution.y;
	float x = v_texCoord.x * resolution.x;

	float dist = (C1 * amplitude * sin(C2 * frequency * y + C3 * u_speed * u_tick));

	if(u_dist_type == 0)	// none
	{
		dx = 0.0;
	}
	else if(u_dist_type == 1)	// horizontal
	{
		dx = dist;
		dx /= resolution.y;
	}
	else if(u_dist_type == 2)	// horizontal interlaced
	{
		dx = floor(mod(y, 2.0)) == 0.0 ? dist : -dist;
		dx /= resolution.y;
	}
	else if(u_dist_type == 3)	// vertical
	{
		dy = mod(y * (compression / 256.0) + dist, 256.0);
		//if(dy < 0.0) dy = 256.0 + dy;
		//if(dy > 256.0) dy = 256.0 - dy;
		
		dy /= resolution.y;
	}
	else
	{
		// well this is awkward
	}
	
	//dx /= resolution.y;
	//dy /= resolution.y;
	dx += u_hoffset / resolution.x;
	dy += u_voffset / resolution.y;

	gl_FragColor = texture2D(s_texture, vec2(dx + v_texCoord.x, dy + v_texCoord.y) );
}

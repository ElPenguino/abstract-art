precision mediump float;

varying vec2 v_texCoord;
uniform sampler2D s_textureA, s_textureB;

uniform vec2 resolution;

uniform vec2 u_ampl, u_freq, u_comp;
uniform vec2 u_speed;

uniform vec2 scroll_x;
uniform vec2 scroll_y;

uniform ivec2 u_dist_type;

vec2 compute_offset(int layer);

void main()
{
	vec2 offsetA = compute_offset(0);
	vec2 offsetB = compute_offset(1);
	
	vec4 colorA = texture2D(s_textureA, offsetA + v_texCoord);
	vec4 colorB = texture2D(s_textureB, offsetB + v_texCoord);
	
	gl_FragColor = (colorA + colorB) * 0.5;
}

vec2 compute_offset(int layer)
{
	vec2 offset = vec2(0.0);

	float y = v_texCoord.y * resolution.y;
	
	float dist = (u_ampl[layer] * sin(u_freq[layer] * y + u_speed[layer]));
	
	if(u_dist_type[layer] == 0)		// none
	{
		offset.x = 0.0;
	}
	else if(u_dist_type[layer] == 1)	// horizontal effect
	{
		offset.x = dist;
	}
	else if(u_dist_type[layer] == 2)	// horizontal interlaced effect
	{
		offset.x = floor(mod(y, 2.0)) == 0.0 ? dist : -dist;
	}
	else if(u_dist_type[layer] == 3)	// vertical effect
	{
		offset.y = mod(dist, resolution.y);
	}
	
	offset.y += (y * (u_comp[layer] / resolution.y));	// compression effect
	
	offset.x += scroll_x[layer];							// translation effect
	offset.y += scroll_y[layer];
	
	offset /= resolution;						// scale values down to 0.0-1.0

	return offset;
}
precision mediump float;

varying vec2 v_texCoord;
uniform sampler2D s_textureA, s_textureB, s_palette;

uniform vec2 resolution;

uniform vec2 u_ampl, u_freq, u_comp;
uniform vec2 u_speed;
uniform vec2 u_pal_cycle_begin, u_pal_cycle_end;
uniform vec2 u_pal_rotation;

uniform vec2 scroll_x;
uniform vec2 scroll_y;

uniform ivec2 u_dist_type;

vec2 compute_offset(int layer);

void main()
{
	vec2 offsetA = compute_offset(0);
	vec2 offsetB = compute_offset(1);
	
	
	float indexA = texture2D(s_textureA, offsetA + v_texCoord).r * 256.0; // get index number
	float indexB = texture2D(s_textureB, offsetB + v_texCoord).r * 256.0;
	
	// perform palette cycle animation
	if(indexA >= u_pal_cycle_begin[0] && indexA <= u_pal_cycle_end[0])
	{
		//indexA = indexA + u_pal_cycle_begin[0]- u_pal_rotation[0] + u_pal_cycle_end[0] + 1.0;
		indexA = mod(indexA + u_pal_rotation[0], u_pal_cycle_end[0]) + u_pal_cycle_begin[0];
	}

	if(indexB >= u_pal_cycle_begin[1] && indexB <= u_pal_cycle_end[1] + 1.0)
	{
		indexB = mod(indexB + u_pal_rotation[1], u_pal_cycle_end[1]) + u_pal_cycle_begin[1];
	}
	
	indexA /= 16.0;
	indexB /= 16.0;
	
	
	
	vec4 colorA = texture2D(s_palette, vec2(indexA, 0.0));
	vec4 colorB = texture2D(s_palette, vec2(indexB, 0.0));
	



	//colorB.a *= 0.5;
	//gl_FragColor.a = colorB.a + colorA.a - (colorB.a * colorA.a);
	//gl_FragColor.rgb = (1.0 - (colorB.a / gl_FragColor.a)) * colorA.rgb + (colorB.a / gl_FragColor.a) * ((1.0 - colorA.a) * colorB.rgb + colorA.a * colorB.rgb);
	
	

	colorB.a *= 0.5;
	gl_FragColor.rgb = colorB.rgb * colorB.a + colorA.rgb * (1.0 - colorB.a);
	gl_FragColor.a = 1.0;
}

vec2 compute_offset(int layer)
{
	vec2 offset = vec2(0.0);

	float y = v_texCoord.y * resolution.y;
	
	float dist = (u_ampl[layer] * sin(u_freq[layer] * y + u_speed[layer]));
	
	if(u_dist_type[layer] == 0)		// none
	{
		offset.x = 0.0;
	}
	else if(u_dist_type[layer] == 1)	// horizontal effect
	{
		offset.x = dist;
	}
	else if(u_dist_type[layer] == 2)	// horizontal interlaced effect
	{
		offset.x = floor(mod(y, 2.0)) == 0.0 ? dist : -dist;
	}
	else if(u_dist_type[layer] == 3)	// vertical effect
	{
		offset.y = mod(dist, resolution.y);
	}
	
	if(u_dist_type[layer] == 4)	// horizontal interlaced + shear
	{
		offset.x = floor(mod(y, 2.0)) == 0.0 ? dist : -dist;
		offset.x += (y * (u_comp[layer] / resolution.y));
	}
	else
	{
		offset.y += (y * (u_comp[layer] / resolution.y));	// compression effect
	}
	
	offset.x += scroll_x[layer];							// translation effect
	offset.y += scroll_y[layer];
	
	offset /= resolution;						// scale values down to 0.0-1.0

	return offset;
}
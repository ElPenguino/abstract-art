precision highp float;

varying vec2 v_texCoord;
uniform sampler2D s_textureA, s_textureB, s_palette;

uniform vec2 resolution;

uniform vec2 u_ampl, u_freq, u_comp;
uniform vec2 u_speed;
uniform vec2 u_pal_cycle1_begin, u_pal_cycle1_end;
uniform vec2 u_pal_cycle2_begin, u_pal_cycle2_end;
uniform vec2 u_pal_rotation;

uniform vec2 scroll_x;
uniform vec2 scroll_y;

uniform ivec2 u_dist_type, u_cycle_type;

vec2 compute_offset(int layer);

void main()
{
	vec2 offsetA = compute_offset(0);
	vec2 offsetB = compute_offset(1);
	
	
	float indexA = texture2D(s_textureA, offsetA + v_texCoord).r * 256.0; // get index number
	float indexB = texture2D(s_textureB, offsetB + v_texCoord).r * 256.0;
	
	if(v_texCoord.y * resolution.y >= 224.0)
		discard;
	
	indexA = floor(indexA + 0.5);
	
	if(u_cycle_type[0] == 1) // circular palette rotation
	{
		if(indexA >= u_pal_cycle1_begin[0] - 0.5 && indexA <= u_pal_cycle1_end[0] + 0.5)
		{
			float range = u_pal_cycle1_end[0] - u_pal_cycle1_begin[0];
			indexA = indexA - u_pal_rotation[0];
			
			if(indexA < u_pal_cycle1_begin[0]) {
				indexA = u_pal_cycle1_end[0] + 1.0 - abs(u_pal_cycle1_begin[0] - indexA);
			}
		}
	}
	else if(u_cycle_type[0] == 2) //
	{
		if(indexA >= u_pal_cycle1_begin[0] - 0.5 && indexA <= u_pal_cycle1_end[0] + 0.5)
		{
			float range = u_pal_cycle1_end[0] - u_pal_cycle1_begin[0];
			indexA = indexA - u_pal_rotation[0];
			
			if(indexA < u_pal_cycle1_begin[0]) {
				indexA = u_pal_cycle1_end[0] + 1.0 - abs(u_pal_cycle1_begin[0] - indexA);
			}
		}
		else if(indexA >= u_pal_cycle2_begin[0] - 0.5 && indexA <= u_pal_cycle2_end[0] + 0.5)
		{
			float range = u_pal_cycle2_end[0] - u_pal_cycle2_begin[0];
			indexA = indexA - u_pal_rotation[0];
			
			if(indexA < u_pal_cycle2_begin[0]) {
				indexA = u_pal_cycle2_end[0] + 1.0 - abs(u_pal_cycle2_begin[0] - indexA);
			}
		}
	}
	else if(u_cycle_type[0] == 3) // triangle palette rotation
	{
		if(indexA >= u_pal_cycle1_begin[0] - 0.5 && indexA <= u_pal_cycle1_end[0] + 0.5)
		{
			float range = u_pal_cycle1_end[0] - u_pal_cycle1_begin[0];
			indexA = indexA + u_pal_rotation[0] - u_pal_cycle1_begin[0];
			
			range = floor(range + 0.5);
			indexA = floor(indexA + 0.5);
			
			if(indexA > range * 2.0 + 1.0) {
				indexA = u_pal_cycle1_begin[0] + (indexA - ((range * 2.0) + 2.0));
			}
			else if(indexA > range) {
				indexA = u_pal_cycle1_end[0] - (indexA - (range + 1.0));
			}
			else {
				indexA += u_pal_cycle1_begin[0];
			}
		}
	}
	
	
	

	
	indexA /= 16.0;
	indexB /= 16.0;
	
	
	
	vec4 colorA = texture2D(s_palette, vec2(indexA, 0.0));
	//vec4 colorB = texture2D(s_palette, vec2(indexB, 0.0));
	vec4 colorB = vec4(0.0);


	//colorB.a *= 0.5;
	//gl_FragColor.a = colorB.a + colorA.a - (colorB.a * colorA.a);
	//gl_FragColor.rgb = (1.0 - (colorB.a / gl_FragColor.a)) * colorA.rgb + (colorB.a / gl_FragColor.a) * ((1.0 - colorA.a) * colorB.rgb + colorA.a * colorB.rgb);

	colorB.a *= 0.5;
	gl_FragColor.rgb = colorB.rgb * colorB.a + colorA.rgb * (1.0 - colorB.a);
	gl_FragColor.a = 1.0;
}

vec2 compute_offset(int layer)
{
	vec2 offset = vec2(0.0);

	float y = v_texCoord.y * resolution.y;
	
	float dist = (u_ampl[layer] * sin(u_freq[layer] * y + u_speed[layer]));
	
	if(u_dist_type[layer] == 0)		// none
	{
		offset.x = 0.0;
	}
	else if(u_dist_type[layer] == 1)	// horizontal effect
	{
		offset.x = dist;
	}
	else if(u_dist_type[layer] == 2)	// horizontal interlaced effect
	{
		offset.x = floor(mod(y, 2.0)) == 0.0 ? dist : -dist;
	}
	else if(u_dist_type[layer] == 3)	// vertical effect
	{
		offset.y = mod(dist, resolution.y);
	}
	
	if(u_dist_type[layer] == 4)	// horizontal interlaced + shear
	{
		offset.x = floor(mod(y, 2.0)) == 0.0 ? dist : -dist;
		offset.x += (y * (u_comp[layer] / resolution.y));
	}
	else
	{
		offset.y += (y * (u_comp[layer] / resolution.y));	// compression effect
	}
	
	offset.x += scroll_x[layer];							// translation effect
	offset.y += scroll_y[layer];
	
	offset /= resolution;						// scale values down to 0.0-1.0

	return offset;
}